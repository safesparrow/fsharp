{
  "fileName": "%CODE_ROOT%\\src\\Fantomas.FCS\\Parse.fs",
  "fileVersion": 449326789,
  "sourceText": "module Fantomas.FCS.Parse\n\nopen System\nopen System.Text\nopen System.Diagnostics\nopen FSharp.Compiler.Diagnostics\nopen FSharp.Compiler.DiagnosticMessage\nopen Internal.Utilities\nopen Internal.Utilities.Library\nopen FSharp.Compiler\nopen FSharp.Compiler.AbstractIL.IL\nopen FSharp.Compiler.DiagnosticsLogger\nopen FSharp.Compiler.Features\nopen FSharp.Compiler.Lexhelp\nopen FSharp.Compiler.Text\nopen FSharp.Compiler.Text.Position\nopen FSharp.Compiler.Text.Range\nopen FSharp.Compiler.Xml\nopen FSharp.Compiler.Syntax\nopen FSharp.Compiler.SyntaxTrivia\nopen FSharp.Compiler.Syntax.PrettyNaming\nopen FSharp.Compiler.SyntaxTreeOps\nopen FSharp.Compiler.IO\nopen FSharp.Compiler.ParseHelpers\n\nlet private FSharpSigFileSuffixes = [ \".mli\"; \".fsi\" ]\n\nlet private mlCompatSuffixes = [ \".mli\"; \".ml\" ]\n\nlet private FSharpImplFileSuffixes = [ \".ml\"; \".fs\"; \".fsscript\"; \".fsx\" ]\n\nlet private FSharpScriptFileSuffixes = [ \".fsscript\"; \".fsx\" ]\n\nlet private CanonicalizeFilename filename =\n    let basic = FileSystemUtils.fileNameOfPath filename\n\n    String.capitalize (\n        try\n            FileSystemUtils.chopExtension basic\n        with\n        | _ -> basic\n    )\n\nlet private ComputeAnonModuleName check defaultNamespace filename (m: range) =\n    let modname = CanonicalizeFilename filename\n\n    if\n        check\n        && not\n            (\n                modname\n                |> String.forall (fun c -> Char.IsLetterOrDigit c || c = '_')\n            )\n    then\n        if\n            not\n                (\n                    filename.EndsWith(\"fsx\", StringComparison.OrdinalIgnoreCase)\n                    || filename.EndsWith(\"fsscript\", StringComparison.OrdinalIgnoreCase)\n                )\n        then\n            warning (\n                Error(\n                    FSComp.SR.buildImplicitModuleIsNotLegalIdentifier (\n                        modname,\n                        (FileSystemUtils.fileNameOfPath filename)\n                    ),\n                    m\n                )\n            )\n\n    let combined =\n        match defaultNamespace with\n        | None -> modname\n        | Some ns -> textOfPath [ ns; modname ]\n\n    let anonymousModuleNameRange =\n        let filename = m.FileName\n        mkRange filename pos0 pos0\n\n    pathToSynLid anonymousModuleNameRange (splitNamespace combined)\n\nlet private IsScript filename =\n    let lower = String.lowercase filename\n\n    FSharpScriptFileSuffixes\n    |> List.exists (FileSystemUtils.checkSuffix lower)\n\nlet private PostParseModuleImpl (_i, defaultNamespace, _isLastCompiland, filename, impl) =\n    match impl with\n    | ParsedImplFileFragment.NamedModule (SynModuleOrNamespace (lid,\n                                                                isRec,\n                                                                kind,\n                                                                decls,\n                                                                xmlDoc,\n                                                                attribs,\n                                                                access,\n                                                                m,\n                                                                trivia)) ->\n        let lid =\n            match lid with\n            | [ id ] when kind.IsModule && id.idText = MangledGlobalName ->\n                error (Error(FSComp.SR.buildInvalidModuleOrNamespaceName (), id.idRange))\n            | id :: rest when id.idText = MangledGlobalName -> rest\n            | _ -> lid\n\n        SynModuleOrNamespace(lid, isRec, kind, decls, xmlDoc, attribs, access, m, trivia)\n\n    | ParsedImplFileFragment.AnonModule (defs, m) ->\n        let modname =\n            ComputeAnonModuleName (not (isNil defs)) defaultNamespace filename (trimRangeToLine m)\n\n        let trivia: SynModuleOrNamespaceTrivia =\n            { ModuleKeyword = None\n              NamespaceKeyword = None }\n\n        SynModuleOrNamespace(\n            modname,\n            false,\n            SynModuleOrNamespaceKind.AnonModule,\n            defs,\n            PreXmlDoc.Empty,\n            [],\n            None,\n            m,\n            trivia\n        )\n\n    | ParsedImplFileFragment.NamespaceFragment (lid, isRecursive, kind, decls, xmlDoc, attributes, range, trivia) ->\n        let lid, kind =\n            match lid with\n            | id :: rest when id.idText = MangledGlobalName ->\n                rest,\n                if List.isEmpty rest then\n                    SynModuleOrNamespaceKind.GlobalNamespace\n                else\n                    kind\n            | _ -> lid, kind\n\n        SynModuleOrNamespace(lid, isRecursive, kind, decls, xmlDoc, attributes, None, range, trivia)\n\n// Give a unique name to the different kinds of inputs. Used to correlate signature and implementation files\n//   QualFileNameOfModuleName - files with a single module declaration or an anonymous module\nlet private QualFileNameOfModuleName m filename modname =\n    QualifiedNameOfFile(\n        mkSynId\n            m\n            (textOfLid modname\n             + (if IsScript filename then \"$fsx\" else \"\"))\n    )\n\nlet private QualFileNameOfFilename m filename =\n    QualifiedNameOfFile(\n        mkSynId\n            m\n            (CanonicalizeFilename filename\n             + (if IsScript filename then \"$fsx\" else \"\"))\n    )\n\nlet private QualFileNameOfSpecs filename specs =\n    match specs with\n    | [ SynModuleOrNamespaceSig (longId = modname; kind = kind; range = m) ] when kind.IsModule ->\n        QualFileNameOfModuleName m filename modname\n    | [ SynModuleOrNamespaceSig (kind = kind; range = m) ] when not kind.IsModule -> QualFileNameOfFilename m filename\n    | _ -> QualFileNameOfFilename (mkRange filename pos0 pos0) filename\n\nlet private QualFileNameOfImpls filename specs =\n    match specs with\n    | [ SynModuleOrNamespace (longId = modname; kind = kind; range = m) ] when kind.IsModule ->\n        QualFileNameOfModuleName m filename modname\n    | [ SynModuleOrNamespace (kind = kind; range = m) ] when not kind.IsModule -> QualFileNameOfFilename m filename\n    | _ -> QualFileNameOfFilename (mkRange filename pos0 pos0) filename\n\nlet private GetScopedPragmasForInput input =\n    match input with\n    | ParsedInput.SigFile (ParsedSigFileInput (scopedPragmas = pragmas)) -> pragmas\n    | ParsedInput.ImplFile (ParsedImplFileInput (scopedPragmas = pragmas)) -> pragmas\n\nlet private collectCodeComments (lexbuf: UnicodeLexing.Lexbuf) (tripleSlashComments: range list) =\n    [ yield! LexbufCommentStore.GetComments(lexbuf)\n      yield! (List.map CommentTrivia.LineComment tripleSlashComments) ]\n    |> List.sortBy (function\n        | CommentTrivia.LineComment r\n        | CommentTrivia.BlockComment r -> r.StartLine, r.StartColumn)\n\nlet private PostParseModuleImpls\n    (\n        defaultNamespace,\n        filename,\n        isLastCompiland,\n        ParsedImplFile (hashDirectives, impls),\n        lexbuf: UnicodeLexing.Lexbuf,\n        tripleSlashComments: range list\n    ) =\n    match impls\n          |> List.rev\n          |> List.tryPick (function\n              | ParsedImplFileFragment.NamedModule (SynModuleOrNamespace (longId = lid)) -> Some lid\n              | _ -> None)\n        with\n    | Some lid when impls.Length > 1 -> errorR (Error(FSComp.SR.buildMultipleToplevelModules (), rangeOfLid lid))\n    | _ -> ()\n\n    let impls =\n        impls\n        |> List.mapi (fun i x -> PostParseModuleImpl(i, defaultNamespace, isLastCompiland, filename, x))\n\n    let qualName = QualFileNameOfImpls filename impls\n    let isScript = IsScript filename\n\n    let scopedPragmas = []\n    let conditionalDirectives = LexbufIfdefStore.GetTrivia(lexbuf)\n    let codeComments = collectCodeComments lexbuf tripleSlashComments\n\n    ParsedInput.ImplFile(\n        ParsedImplFileInput(\n            filename,\n            isScript,\n            qualName,\n            scopedPragmas,\n            hashDirectives,\n            impls,\n            isLastCompiland,\n            { ConditionalDirectives = conditionalDirectives\n              CodeComments = codeComments }\n        )\n    )\n\nlet private PostParseModuleSpec (_i, defaultNamespace, _isLastCompiland, filename, intf) =\n    match intf with\n    | ParsedSigFileFragment.NamedModule (SynModuleOrNamespaceSig (lid,\n                                                                  isRec,\n                                                                  kind,\n                                                                  decls,\n                                                                  xmlDoc,\n                                                                  attribs,\n                                                                  access,\n                                                                  m,\n                                                                  trivia)) ->\n        let lid =\n            match lid with\n            | [ id ] when kind.IsModule && id.idText = MangledGlobalName ->\n                error (Error(FSComp.SR.buildInvalidModuleOrNamespaceName (), id.idRange))\n            | id :: rest when id.idText = MangledGlobalName -> rest\n            | _ -> lid\n\n        SynModuleOrNamespaceSig(\n            lid,\n            isRec,\n            SynModuleOrNamespaceKind.NamedModule,\n            decls,\n            xmlDoc,\n            attribs,\n            access,\n            m,\n            trivia\n        )\n\n    | ParsedSigFileFragment.AnonModule (defs, m) ->\n        let modname =\n            ComputeAnonModuleName (not (isNil defs)) defaultNamespace filename (trimRangeToLine m)\n\n        let trivia: SynModuleOrNamespaceSigTrivia =\n            { ModuleKeyword = None\n              NamespaceKeyword = None }\n\n        SynModuleOrNamespaceSig(\n            modname,\n            false,\n            SynModuleOrNamespaceKind.AnonModule,\n            defs,\n            PreXmlDoc.Empty,\n            [],\n            None,\n            m,\n            trivia\n        )\n\n    | ParsedSigFileFragment.NamespaceFragment (lid, isRecursive, kind, decls, xmlDoc, attributes, range, trivia) ->\n        let lid, kind =\n            match lid with\n            | id :: rest when id.idText = MangledGlobalName ->\n                rest,\n                if List.isEmpty rest then\n                    SynModuleOrNamespaceKind.GlobalNamespace\n                else\n                    kind\n            | _ -> lid, kind\n\n        SynModuleOrNamespaceSig(lid, isRecursive, kind, decls, xmlDoc, attributes, None, range, trivia)\n\nlet private PostParseModuleSpecs\n    (\n        defaultNamespace,\n        filename,\n        isLastCompiland,\n        ParsedSigFile (hashDirectives, specs),\n        lexbuf: UnicodeLexing.Lexbuf,\n        tripleSlashComments: range list\n    ) =\n    match specs\n          |> List.rev\n          |> List.tryPick (function\n              | ParsedSigFileFragment.NamedModule (SynModuleOrNamespaceSig (longId = lid)) -> Some lid\n              | _ -> None)\n        with\n    | Some lid when specs.Length > 1 -> errorR (Error(FSComp.SR.buildMultipleToplevelModules (), rangeOfLid lid))\n    | _ -> ()\n\n    let specs =\n        specs\n        |> List.mapi (fun i x -> PostParseModuleSpec(i, defaultNamespace, isLastCompiland, filename, x))\n\n    let qualName = QualFileNameOfSpecs filename specs\n    let scopedPragmas = []\n\n    let conditionalDirectives = LexbufIfdefStore.GetTrivia(lexbuf)\n    let codeComments = collectCodeComments lexbuf tripleSlashComments\n\n    ParsedInput.SigFile(\n        ParsedSigFileInput(\n            filename,\n            qualName,\n            scopedPragmas,\n            hashDirectives,\n            specs,\n            { ConditionalDirectives = conditionalDirectives\n              CodeComments = codeComments }\n        )\n    )\n\nlet private ParseInput\n    (\n        lexer,\n        errorLogger: CapturingDiagnosticsLogger,\n        lexbuf: UnicodeLexing.Lexbuf,\n        defaultNamespace,\n        filename,\n        isLastCompiland\n    ) =\n    // The assert below is almost ok, but it fires in two cases:\n    //  - fsi.exe sometimes passes \"stdin\" as a dummy filename\n    //  - if you have a #line directive, e.g.\n    //        # 1000 \"Line01.fs\"\n    //    then it also asserts. But these are edge cases that can be fixed later, e.g. in bug 4651.\n    //System.Diagnostics.Debug.Assert(System.IO.Path.IsPathRooted filename, sprintf \"should be absolute: '%s'\" filename)\n    let lower = String.lowercase filename\n\n    // Delay sending errors and warnings until after the file is parsed. This gives us a chance to scrape the\n    // #nowarn declarations for the file\n    let delayLogger = CapturingDiagnosticsLogger(\"Parsing\")\n    use unwindEL = PushDiagnosticsLoggerPhaseUntilUnwind(fun _ -> delayLogger)\n    use unwindBP = PushThreadBuildPhaseUntilUnwind BuildPhase.Parse\n\n    let mutable scopedPragmas = []\n\n    try\n        let input =\n            if\n                mlCompatSuffixes\n                |> List.exists (FileSystemUtils.checkSuffix lower)\n            then\n                if lexbuf.SupportsFeature LanguageFeature.MLCompatRevisions then\n                    errorR (Error(FSComp.SR.buildInvalidSourceFileExtensionML filename, rangeStartup))\n                else\n                    mlCompatWarning (FSComp.SR.buildCompilingExtensionIsForML ()) rangeStartup\n\n            // Call the appropriate parser - for signature files or implementation files\n            if\n                FSharpImplFileSuffixes\n                |> List.exists (FileSystemUtils.checkSuffix lower)\n            then\n                let impl = Parser.implementationFile lexer lexbuf\n\n                let tripleSlashComments =\n                    LexbufLocalXmlDocStore.ReportInvalidXmlDocPositions(lexbuf)\n\n                PostParseModuleImpls(defaultNamespace, filename, isLastCompiland, impl, lexbuf, tripleSlashComments)\n            elif\n                FSharpSigFileSuffixes\n                |> List.exists (FileSystemUtils.checkSuffix lower)\n            then\n                let intfs = Parser.signatureFile lexer lexbuf\n\n                let tripleSlashComments =\n                    LexbufLocalXmlDocStore.ReportInvalidXmlDocPositions(lexbuf)\n\n                PostParseModuleSpecs(defaultNamespace, filename, isLastCompiland, intfs, lexbuf, tripleSlashComments)\n            else if lexbuf.SupportsFeature LanguageFeature.MLCompatRevisions then\n                error (Error(FSComp.SR.buildInvalidSourceFileExtensionUpdated filename, rangeStartup))\n            else\n                error (Error(FSComp.SR.buildInvalidSourceFileExtension filename, rangeStartup))\n\n        scopedPragmas <- GetScopedPragmasForInput input\n        input\n    finally\n        // OK, now commit the errors, since the ScopedPragmas will (hopefully) have been scraped\n        let filteringErrorLogger = errorLogger // TODO: does this matter? //GetErrorLoggerFilteringByScopedPragmas(false, scopedPragmas, diagnosticOptions, errorLogger)\n        delayLogger.CommitDelayedDiagnostics filteringErrorLogger\n\nlet private EmptyParsedInput (filename, isLastCompiland) =\n    let lower = String.lowercase filename\n\n    if\n        FSharpSigFileSuffixes\n        |> List.exists (FileSystemUtils.checkSuffix lower)\n    then\n        ParsedInput.SigFile(\n            ParsedSigFileInput(\n                filename,\n                QualFileNameOfImpls filename [],\n                [],\n                [],\n                [],\n                { ConditionalDirectives = []\n                  CodeComments = [] }\n            )\n        )\n    else\n        ParsedInput.ImplFile(\n            ParsedImplFileInput(\n                filename,\n                false,\n                QualFileNameOfImpls filename [],\n                [],\n                [],\n                [],\n                isLastCompiland,\n                { ConditionalDirectives = []\n                  CodeComments = [] }\n            )\n        )\n\nlet private createLexbuf langVersion sourceText =\n    UnicodeLexing.SourceTextAsLexbuf(true, LanguageVersion(langVersion), sourceText)\n\nlet private createLexerFunction (defines: string list) lexbuf (errorLogger: CapturingDiagnosticsLogger) =\n    let lightStatus = IndentationAwareSyntaxStatus(true, true)\n\n    // Note: we don't really attempt to intern strings across a large scope.\n    let lexResourceManager = LexResourceManager()\n\n    let lexargs =\n        mkLexargs (defines, lightStatus, lexResourceManager, [], errorLogger, PathMap.empty)\n\n    let lexargs = { lexargs with applyLineDirectives = false }\n\n    let compilingFsLib = false\n\n    let tokenizer =\n        LexFilter.LexFilter(lightStatus, compilingFsLib, Lexer.token lexargs true, lexbuf)\n\n    (fun _ -> tokenizer.GetToken())\n\ntype FSharpParserDiagnostic =\n    { Severity: FSharpDiagnosticSeverity\n      SubCategory: string\n      Range: range option\n      // GetDiagnosticNumber from dotnet/fsharp/src/fsharp/CompilerDiagnostics.fs\n      ErrorNumber: int option\n      Message: string }\n\nlet private getErrorString key = SR.GetString key\n\nlet private UnexpectedEndOfInputE () =\n    DeclareResourceString(\"UnexpectedEndOfInput\", \"\")\n\nlet private OBlockEndSentenceE () =\n    DeclareResourceString(\"BlockEndSentence\", \"\")\n\nlet private UnexpectedE () =\n    DeclareResourceString(\"Unexpected\", \"%s\")\n\nlet private NONTERM_interactionE () =\n    DeclareResourceString(\"NONTERM.interaction\", \"\")\n\nlet private NONTERM_hashDirectiveE () =\n    DeclareResourceString(\"NONTERM.hashDirective\", \"\")\n\nlet private NONTERM_fieldDeclE () =\n    DeclareResourceString(\"NONTERM.fieldDecl\", \"\")\n\nlet private NONTERM_unionCaseReprE () =\n    DeclareResourceString(\"NONTERM.unionCaseRepr\", \"\")\n\nlet private NONTERM_localBindingE () =\n    DeclareResourceString(\"NONTERM.localBinding\", \"\")\n\nlet private NONTERM_hardwhiteLetBindingsE () =\n    DeclareResourceString(\"NONTERM.hardwhiteLetBindings\", \"\")\n\nlet private NONTERM_classDefnMemberE () =\n    DeclareResourceString(\"NONTERM.classDefnMember\", \"\")\n\nlet private NONTERM_defnBindingsE () =\n    DeclareResourceString(\"NONTERM.defnBindings\", \"\")\n\nlet private NONTERM_classMemberSpfnE () =\n    DeclareResourceString(\"NONTERM.classMemberSpfn\", \"\")\n\nlet private NONTERM_valSpfnE () =\n    DeclareResourceString(\"NONTERM.valSpfn\", \"\")\n\nlet private NONTERM_tyconSpfnE () =\n    DeclareResourceString(\"NONTERM.tyconSpfn\", \"\")\n\nlet private NONTERM_anonLambdaExprE () =\n    DeclareResourceString(\"NONTERM.anonLambdaExpr\", \"\")\n\nlet private NONTERM_attrUnionCaseDeclE () =\n    DeclareResourceString(\"NONTERM.attrUnionCaseDecl\", \"\")\n\nlet private NONTERM_cPrototypeE () =\n    DeclareResourceString(\"NONTERM.cPrototype\", \"\")\n\nlet private NONTERM_objectImplementationMembersE () =\n    DeclareResourceString(\"NONTERM.objectImplementationMembers\", \"\")\n\nlet private NONTERM_ifExprCasesE () =\n    DeclareResourceString(\"NONTERM.ifExprCases\", \"\")\n\nlet private NONTERM_openDeclE () =\n    DeclareResourceString(\"NONTERM.openDecl\", \"\")\n\nlet private NONTERM_fileModuleSpecE () =\n    DeclareResourceString(\"NONTERM.fileModuleSpec\", \"\")\n\nlet private NONTERM_patternClausesE () =\n    DeclareResourceString(\"NONTERM.patternClauses\", \"\")\n\nlet private NONTERM_beginEndExprE () =\n    DeclareResourceString(\"NONTERM.beginEndExpr\", \"\")\n\nlet private NONTERM_recdExprE () =\n    DeclareResourceString(\"NONTERM.recdExpr\", \"\")\n\nlet private NONTERM_tyconDefnE () =\n    DeclareResourceString(\"NONTERM.tyconDefn\", \"\")\n\nlet private NONTERM_exconCoreE () =\n    DeclareResourceString(\"NONTERM.exconCore\", \"\")\n\nlet private NONTERM_typeNameInfoE () =\n    DeclareResourceString(\"NONTERM.typeNameInfo\", \"\")\n\nlet private NONTERM_attributeListE () =\n    DeclareResourceString(\"NONTERM.attributeList\", \"\")\n\nlet private NONTERM_quoteExprE () =\n    DeclareResourceString(\"NONTERM.quoteExpr\", \"\")\n\nlet private NONTERM_typeConstraintE () =\n    DeclareResourceString(\"NONTERM.typeConstraint\", \"\")\n\nlet private NONTERM_Category_ImplementationFileE () =\n    DeclareResourceString(\"NONTERM.Category.ImplementationFile\", \"\")\n\nlet private NONTERM_Category_DefinitionE () =\n    DeclareResourceString(\"NONTERM.Category.Definition\", \"\")\n\nlet private NONTERM_Category_SignatureFileE () =\n    DeclareResourceString(\"NONTERM.Category.SignatureFile\", \"\")\n\nlet private NONTERM_Category_PatternE () =\n    DeclareResourceString(\"NONTERM.Category.Pattern\", \"\")\n\nlet private NONTERM_Category_ExprE () =\n    DeclareResourceString(\"NONTERM.Category.Expr\", \"\")\n\nlet private NONTERM_Category_TypeE () =\n    DeclareResourceString(\"NONTERM.Category.Type\", \"\")\n\nlet private NONTERM_typeArgsActualE () =\n    DeclareResourceString(\"NONTERM.typeArgsActual\", \"\")\n\nlet private TokenName1E () =\n    DeclareResourceString(\"TokenName1\", \"%s\")\n\nlet private TokenName1TokenName2E () =\n    DeclareResourceString(\"TokenName1TokenName2\", \"%s%s\")\n\nlet private TokenName1TokenName2TokenName3E () =\n    DeclareResourceString(\"TokenName1TokenName2TokenName3\", \"%s%s%s\")\n\nlet private LibraryUseOnlyE () =\n    DeclareResourceString(\"LibraryUseOnly\", \"\")\n\nlet private getSyntaxErrorMessage ctxt =\n    let ctxt =\n        unbox<Internal.Utilities.Text.Parsing.ParseErrorContext<Parser.token>> ctxt\n\n    let os = StringBuilder()\n\n    let (|EndOfStructuredConstructToken|_|) token =\n        match token with\n        | Parser.TOKEN_ODECLEND\n        | Parser.TOKEN_OBLOCKSEP\n        | Parser.TOKEN_OEND\n        | Parser.TOKEN_ORIGHT_BLOCK_END\n        | Parser.TOKEN_OBLOCKEND\n        | Parser.TOKEN_OBLOCKEND_COMING_SOON\n        | Parser.TOKEN_OBLOCKEND_IS_HERE -> Some()\n        | _ -> None\n\n    let tokenIdToText tid =\n        match tid with\n        | Parser.TOKEN_IDENT -> getErrorString \"Parser.TOKEN.IDENT\"\n        | Parser.TOKEN_BIGNUM\n        | Parser.TOKEN_INT8\n        | Parser.TOKEN_UINT8\n        | Parser.TOKEN_INT16\n        | Parser.TOKEN_UINT16\n        | Parser.TOKEN_INT32\n        | Parser.TOKEN_UINT32\n        | Parser.TOKEN_INT64\n        | Parser.TOKEN_UINT64\n        | Parser.TOKEN_UNATIVEINT\n        | Parser.TOKEN_NATIVEINT -> getErrorString \"Parser.TOKEN.INT\"\n        | Parser.TOKEN_IEEE32\n        | Parser.TOKEN_IEEE64 -> getErrorString \"Parser.TOKEN.FLOAT\"\n        | Parser.TOKEN_DECIMAL -> getErrorString \"Parser.TOKEN.DECIMAL\"\n        | Parser.TOKEN_CHAR -> getErrorString \"Parser.TOKEN.CHAR\"\n\n        | Parser.TOKEN_BASE -> getErrorString \"Parser.TOKEN.BASE\"\n        | Parser.TOKEN_LPAREN_STAR_RPAREN -> getErrorString \"Parser.TOKEN.LPAREN.STAR.RPAREN\"\n        | Parser.TOKEN_DOLLAR -> getErrorString \"Parser.TOKEN.DOLLAR\"\n        | Parser.TOKEN_INFIX_STAR_STAR_OP -> getErrorString \"Parser.TOKEN.INFIX.STAR.STAR.OP\"\n        | Parser.TOKEN_INFIX_COMPARE_OP -> getErrorString \"Parser.TOKEN.INFIX.COMPARE.OP\"\n        | Parser.TOKEN_COLON_GREATER -> getErrorString \"Parser.TOKEN.COLON.GREATER\"\n        | Parser.TOKEN_COLON_COLON -> getErrorString \"Parser.TOKEN.COLON.COLON\"\n        | Parser.TOKEN_PERCENT_OP -> getErrorString \"Parser.TOKEN.PERCENT.OP\"\n        | Parser.TOKEN_INFIX_AT_HAT_OP -> getErrorString \"Parser.TOKEN.INFIX.AT.HAT.OP\"\n        | Parser.TOKEN_INFIX_BAR_OP -> getErrorString \"Parser.TOKEN.INFIX.BAR.OP\"\n        | Parser.TOKEN_PLUS_MINUS_OP -> getErrorString \"Parser.TOKEN.PLUS.MINUS.OP\"\n        | Parser.TOKEN_PREFIX_OP -> getErrorString \"Parser.TOKEN.PREFIX.OP\"\n        | Parser.TOKEN_COLON_QMARK_GREATER -> getErrorString \"Parser.TOKEN.COLON.QMARK.GREATER\"\n        | Parser.TOKEN_INFIX_STAR_DIV_MOD_OP -> getErrorString \"Parser.TOKEN.INFIX.STAR.DIV.MOD.OP\"\n        | Parser.TOKEN_INFIX_AMP_OP -> getErrorString \"Parser.TOKEN.INFIX.AMP.OP\"\n        | Parser.TOKEN_AMP -> getErrorString \"Parser.TOKEN.AMP\"\n        | Parser.TOKEN_AMP_AMP -> getErrorString \"Parser.TOKEN.AMP.AMP\"\n        | Parser.TOKEN_BAR_BAR -> getErrorString \"Parser.TOKEN.BAR.BAR\"\n        | Parser.TOKEN_LESS -> getErrorString \"Parser.TOKEN.LESS\"\n        | Parser.TOKEN_GREATER -> getErrorString \"Parser.TOKEN.GREATER\"\n        | Parser.TOKEN_QMARK -> getErrorString \"Parser.TOKEN.QMARK\"\n        | Parser.TOKEN_QMARK_QMARK -> getErrorString \"Parser.TOKEN.QMARK.QMARK\"\n        | Parser.TOKEN_COLON_QMARK -> getErrorString \"Parser.TOKEN.COLON.QMARK\"\n        | Parser.TOKEN_INT32_DOT_DOT -> getErrorString \"Parser.TOKEN.INT32.DOT.DOT\"\n        | Parser.TOKEN_DOT_DOT -> getErrorString \"Parser.TOKEN.DOT.DOT\"\n        | Parser.TOKEN_DOT_DOT_HAT -> getErrorString \"Parser.TOKEN.DOT.DOT\"\n        | Parser.TOKEN_QUOTE -> getErrorString \"Parser.TOKEN.QUOTE\"\n        | Parser.TOKEN_STAR -> getErrorString \"Parser.TOKEN.STAR\"\n        | Parser.TOKEN_HIGH_PRECEDENCE_TYAPP -> getErrorString \"Parser.TOKEN.HIGH.PRECEDENCE.TYAPP\"\n        | Parser.TOKEN_COLON -> getErrorString \"Parser.TOKEN.COLON\"\n        | Parser.TOKEN_COLON_EQUALS -> getErrorString \"Parser.TOKEN.COLON.EQUALS\"\n        | Parser.TOKEN_LARROW -> getErrorString \"Parser.TOKEN.LARROW\"\n        | Parser.TOKEN_EQUALS -> getErrorString \"Parser.TOKEN.EQUALS\"\n        | Parser.TOKEN_GREATER_BAR_RBRACK -> getErrorString \"Parser.TOKEN.GREATER.BAR.RBRACK\"\n        | Parser.TOKEN_MINUS -> getErrorString \"Parser.TOKEN.MINUS\"\n        | Parser.TOKEN_ADJACENT_PREFIX_OP -> getErrorString \"Parser.TOKEN.ADJACENT.PREFIX.OP\"\n        | Parser.TOKEN_FUNKY_OPERATOR_NAME -> getErrorString \"Parser.TOKEN.FUNKY.OPERATOR.NAME\"\n        | Parser.TOKEN_COMMA -> getErrorString \"Parser.TOKEN.COMMA\"\n        | Parser.TOKEN_DOT -> getErrorString \"Parser.TOKEN.DOT\"\n        | Parser.TOKEN_BAR -> getErrorString \"Parser.TOKEN.BAR\"\n        | Parser.TOKEN_HASH -> getErrorString \"Parser.TOKEN.HASH\"\n        | Parser.TOKEN_UNDERSCORE -> getErrorString \"Parser.TOKEN.UNDERSCORE\"\n        | Parser.TOKEN_SEMICOLON -> getErrorString \"Parser.TOKEN.SEMICOLON\"\n        | Parser.TOKEN_SEMICOLON_SEMICOLON -> getErrorString \"Parser.TOKEN.SEMICOLON.SEMICOLON\"\n        | Parser.TOKEN_LPAREN -> getErrorString \"Parser.TOKEN.LPAREN\"\n        | Parser.TOKEN_RPAREN\n        | Parser.TOKEN_RPAREN_COMING_SOON\n        | Parser.TOKEN_RPAREN_IS_HERE -> getErrorString \"Parser.TOKEN.RPAREN\"\n        | Parser.TOKEN_LQUOTE -> getErrorString \"Parser.TOKEN.LQUOTE\"\n        | Parser.TOKEN_LBRACK -> getErrorString \"Parser.TOKEN.LBRACK\"\n        | Parser.TOKEN_LBRACE_BAR -> getErrorString \"Parser.TOKEN.LBRACE.BAR\"\n        | Parser.TOKEN_LBRACK_BAR -> getErrorString \"Parser.TOKEN.LBRACK.BAR\"\n        | Parser.TOKEN_LBRACK_LESS -> getErrorString \"Parser.TOKEN.LBRACK.LESS\"\n        | Parser.TOKEN_LBRACE -> getErrorString \"Parser.TOKEN.LBRACE\"\n        | Parser.TOKEN_BAR_RBRACK -> getErrorString \"Parser.TOKEN.BAR.RBRACK\"\n        | Parser.TOKEN_BAR_RBRACE -> getErrorString \"Parser.TOKEN.BAR.RBRACE\"\n        | Parser.TOKEN_GREATER_RBRACK -> getErrorString \"Parser.TOKEN.GREATER.RBRACK\"\n        | Parser.TOKEN_RQUOTE_DOT _\n        | Parser.TOKEN_RQUOTE -> getErrorString \"Parser.TOKEN.RQUOTE\"\n        | Parser.TOKEN_RBRACK -> getErrorString \"Parser.TOKEN.RBRACK\"\n        | Parser.TOKEN_RBRACE\n        | Parser.TOKEN_RBRACE_COMING_SOON\n        | Parser.TOKEN_RBRACE_IS_HERE -> getErrorString \"Parser.TOKEN.RBRACE\"\n        | Parser.TOKEN_PUBLIC -> getErrorString \"Parser.TOKEN.PUBLIC\"\n        | Parser.TOKEN_PRIVATE -> getErrorString \"Parser.TOKEN.PRIVATE\"\n        | Parser.TOKEN_INTERNAL -> getErrorString \"Parser.TOKEN.INTERNAL\"\n        | Parser.TOKEN_CONSTRAINT -> getErrorString \"Parser.TOKEN.CONSTRAINT\"\n        | Parser.TOKEN_INSTANCE -> getErrorString \"Parser.TOKEN.INSTANCE\"\n        | Parser.TOKEN_DELEGATE -> getErrorString \"Parser.TOKEN.DELEGATE\"\n        | Parser.TOKEN_INHERIT -> getErrorString \"Parser.TOKEN.INHERIT\"\n        | Parser.TOKEN_CONSTRUCTOR -> getErrorString \"Parser.TOKEN.CONSTRUCTOR\"\n        | Parser.TOKEN_DEFAULT -> getErrorString \"Parser.TOKEN.DEFAULT\"\n        | Parser.TOKEN_OVERRIDE -> getErrorString \"Parser.TOKEN.OVERRIDE\"\n        | Parser.TOKEN_ABSTRACT -> getErrorString \"Parser.TOKEN.ABSTRACT\"\n        | Parser.TOKEN_CLASS -> getErrorString \"Parser.TOKEN.CLASS\"\n        | Parser.TOKEN_MEMBER -> getErrorString \"Parser.TOKEN.MEMBER\"\n        | Parser.TOKEN_STATIC -> getErrorString \"Parser.TOKEN.STATIC\"\n        | Parser.TOKEN_NAMESPACE -> getErrorString \"Parser.TOKEN.NAMESPACE\"\n        | Parser.TOKEN_OBLOCKBEGIN -> getErrorString \"Parser.TOKEN.OBLOCKBEGIN\"\n        | EndOfStructuredConstructToken -> getErrorString \"Parser.TOKEN.OBLOCKEND\"\n        | Parser.TOKEN_THEN\n        | Parser.TOKEN_OTHEN -> getErrorString \"Parser.TOKEN.OTHEN\"\n        | Parser.TOKEN_ELSE\n        | Parser.TOKEN_OELSE -> getErrorString \"Parser.TOKEN.OELSE\"\n        | Parser.TOKEN_LET _\n        | Parser.TOKEN_OLET _ -> getErrorString \"Parser.TOKEN.OLET\"\n        | Parser.TOKEN_OBINDER\n        | Parser.TOKEN_BINDER -> getErrorString \"Parser.TOKEN.BINDER\"\n        | Parser.TOKEN_OAND_BANG\n        | Parser.TOKEN_AND_BANG -> getErrorString \"Parser.TOKEN.AND.BANG\"\n        | Parser.TOKEN_ODO -> getErrorString \"Parser.TOKEN.ODO\"\n        | Parser.TOKEN_OWITH -> getErrorString \"Parser.TOKEN.OWITH\"\n        | Parser.TOKEN_OFUNCTION -> getErrorString \"Parser.TOKEN.OFUNCTION\"\n        | Parser.TOKEN_OFUN -> getErrorString \"Parser.TOKEN.OFUN\"\n        | Parser.TOKEN_ORESET -> getErrorString \"Parser.TOKEN.ORESET\"\n        | Parser.TOKEN_ODUMMY -> getErrorString \"Parser.TOKEN.ODUMMY\"\n        | Parser.TOKEN_DO_BANG\n        | Parser.TOKEN_ODO_BANG -> getErrorString \"Parser.TOKEN.ODO.BANG\"\n        | Parser.TOKEN_YIELD -> getErrorString \"Parser.TOKEN.YIELD\"\n        | Parser.TOKEN_YIELD_BANG -> getErrorString \"Parser.TOKEN.YIELD.BANG\"\n        | Parser.TOKEN_OINTERFACE_MEMBER -> getErrorString \"Parser.TOKEN.OINTERFACE.MEMBER\"\n        | Parser.TOKEN_ELIF -> getErrorString \"Parser.TOKEN.ELIF\"\n        | Parser.TOKEN_RARROW -> getErrorString \"Parser.TOKEN.RARROW\"\n        | Parser.TOKEN_SIG -> getErrorString \"Parser.TOKEN.SIG\"\n        | Parser.TOKEN_STRUCT -> getErrorString \"Parser.TOKEN.STRUCT\"\n        | Parser.TOKEN_UPCAST -> getErrorString \"Parser.TOKEN.UPCAST\"\n        | Parser.TOKEN_DOWNCAST -> getErrorString \"Parser.TOKEN.DOWNCAST\"\n        | Parser.TOKEN_NULL -> getErrorString \"Parser.TOKEN.NULL\"\n        | Parser.TOKEN_RESERVED -> getErrorString \"Parser.TOKEN.RESERVED\"\n        | Parser.TOKEN_MODULE\n        | Parser.TOKEN_MODULE_COMING_SOON\n        | Parser.TOKEN_MODULE_IS_HERE -> getErrorString \"Parser.TOKEN.MODULE\"\n        | Parser.TOKEN_AND -> getErrorString \"Parser.TOKEN.AND\"\n        | Parser.TOKEN_AS -> getErrorString \"Parser.TOKEN.AS\"\n        | Parser.TOKEN_ASSERT -> getErrorString \"Parser.TOKEN.ASSERT\"\n        | Parser.TOKEN_OASSERT -> getErrorString \"Parser.TOKEN.ASSERT\"\n        | Parser.TOKEN_ASR -> getErrorString \"Parser.TOKEN.ASR\"\n        | Parser.TOKEN_DOWNTO -> getErrorString \"Parser.TOKEN.DOWNTO\"\n        | Parser.TOKEN_EXCEPTION -> getErrorString \"Parser.TOKEN.EXCEPTION\"\n        | Parser.TOKEN_FALSE -> getErrorString \"Parser.TOKEN.FALSE\"\n        | Parser.TOKEN_FOR -> getErrorString \"Parser.TOKEN.FOR\"\n        | Parser.TOKEN_FUN -> getErrorString \"Parser.TOKEN.FUN\"\n        | Parser.TOKEN_FUNCTION -> getErrorString \"Parser.TOKEN.FUNCTION\"\n        | Parser.TOKEN_FINALLY -> getErrorString \"Parser.TOKEN.FINALLY\"\n        | Parser.TOKEN_LAZY -> getErrorString \"Parser.TOKEN.LAZY\"\n        | Parser.TOKEN_OLAZY -> getErrorString \"Parser.TOKEN.LAZY\"\n        | Parser.TOKEN_MATCH -> getErrorString \"Parser.TOKEN.MATCH\"\n        | Parser.TOKEN_MATCH_BANG -> getErrorString \"Parser.TOKEN.MATCH.BANG\"\n        | Parser.TOKEN_MUTABLE -> getErrorString \"Parser.TOKEN.MUTABLE\"\n        | Parser.TOKEN_NEW -> getErrorString \"Parser.TOKEN.NEW\"\n        | Parser.TOKEN_OF -> getErrorString \"Parser.TOKEN.OF\"\n        | Parser.TOKEN_OPEN -> getErrorString \"Parser.TOKEN.OPEN\"\n        | Parser.TOKEN_OR -> getErrorString \"Parser.TOKEN.OR\"\n        | Parser.TOKEN_VOID -> getErrorString \"Parser.TOKEN.VOID\"\n        | Parser.TOKEN_EXTERN -> getErrorString \"Parser.TOKEN.EXTERN\"\n        | Parser.TOKEN_INTERFACE -> getErrorString \"Parser.TOKEN.INTERFACE\"\n        | Parser.TOKEN_REC -> getErrorString \"Parser.TOKEN.REC\"\n        | Parser.TOKEN_TO -> getErrorString \"Parser.TOKEN.TO\"\n        | Parser.TOKEN_TRUE -> getErrorString \"Parser.TOKEN.TRUE\"\n        | Parser.TOKEN_TRY -> getErrorString \"Parser.TOKEN.TRY\"\n        | Parser.TOKEN_TYPE\n        | Parser.TOKEN_TYPE_COMING_SOON\n        | Parser.TOKEN_TYPE_IS_HERE -> getErrorString \"Parser.TOKEN.TYPE\"\n        | Parser.TOKEN_VAL -> getErrorString \"Parser.TOKEN.VAL\"\n        | Parser.TOKEN_INLINE -> getErrorString \"Parser.TOKEN.INLINE\"\n        | Parser.TOKEN_WHEN -> getErrorString \"Parser.TOKEN.WHEN\"\n        | Parser.TOKEN_WHILE -> getErrorString \"Parser.TOKEN.WHILE\"\n        | Parser.TOKEN_WITH -> getErrorString \"Parser.TOKEN.WITH\"\n        | Parser.TOKEN_IF -> getErrorString \"Parser.TOKEN.IF\"\n        | Parser.TOKEN_DO -> getErrorString \"Parser.TOKEN.DO\"\n        | Parser.TOKEN_GLOBAL -> getErrorString \"Parser.TOKEN.GLOBAL\"\n        | Parser.TOKEN_DONE -> getErrorString \"Parser.TOKEN.DONE\"\n        | Parser.TOKEN_IN\n        | Parser.TOKEN_JOIN_IN -> getErrorString \"Parser.TOKEN.IN\"\n        | Parser.TOKEN_HIGH_PRECEDENCE_PAREN_APP -> getErrorString \"Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP\"\n        | Parser.TOKEN_HIGH_PRECEDENCE_BRACK_APP -> getErrorString \"Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP\"\n        | Parser.TOKEN_BEGIN -> getErrorString \"Parser.TOKEN.BEGIN\"\n        | Parser.TOKEN_END -> getErrorString \"Parser.TOKEN.END\"\n        | Parser.TOKEN_HASH_LIGHT\n        | Parser.TOKEN_HASH_LINE\n        | Parser.TOKEN_HASH_IF\n        | Parser.TOKEN_HASH_ELSE\n        | Parser.TOKEN_HASH_ENDIF -> getErrorString \"Parser.TOKEN.HASH.ENDIF\"\n        | Parser.TOKEN_INACTIVECODE -> getErrorString \"Parser.TOKEN.INACTIVECODE\"\n        | Parser.TOKEN_LEX_FAILURE -> getErrorString \"Parser.TOKEN.LEX.FAILURE\"\n        | Parser.TOKEN_WHITESPACE -> getErrorString \"Parser.TOKEN.WHITESPACE\"\n        | Parser.TOKEN_COMMENT -> getErrorString \"Parser.TOKEN.COMMENT\"\n        | Parser.TOKEN_LINE_COMMENT -> getErrorString \"Parser.TOKEN.LINE.COMMENT\"\n        | Parser.TOKEN_STRING_TEXT -> getErrorString \"Parser.TOKEN.STRING.TEXT\"\n        | Parser.TOKEN_BYTEARRAY -> getErrorString \"Parser.TOKEN.BYTEARRAY\"\n        | Parser.TOKEN_STRING -> getErrorString \"Parser.TOKEN.STRING\"\n        | Parser.TOKEN_KEYWORD_STRING -> getErrorString \"Parser.TOKEN.KEYWORD_STRING\"\n        | Parser.TOKEN_EOF -> getErrorString \"Parser.TOKEN.EOF\"\n        | Parser.TOKEN_CONST -> getErrorString \"Parser.TOKEN.CONST\"\n        | Parser.TOKEN_FIXED -> getErrorString \"Parser.TOKEN.FIXED\"\n        | Parser.TOKEN_INTERP_STRING_BEGIN_END -> getErrorString \"Parser.TOKEN.INTERP.STRING.BEGIN.END\"\n        | Parser.TOKEN_INTERP_STRING_BEGIN_PART -> getErrorString \"Parser.TOKEN.INTERP.STRING.BEGIN.PART\"\n        | Parser.TOKEN_INTERP_STRING_PART -> getErrorString \"Parser.TOKEN.INTERP.STRING.PART\"\n        | Parser.TOKEN_INTERP_STRING_END -> getErrorString \"Parser.TOKEN.INTERP.STRING.END\"\n        | unknown ->\n            Debug.Assert(false, \"unknown token tag\")\n            let result = $\"%+A{unknown}\"\n            Debug.Assert(false, result)\n            result\n\n    match ctxt.CurrentToken with\n    | None ->\n        os.Append(UnexpectedEndOfInputE().Format)\n        |> ignore\n    | Some token ->\n        match (token\n               |> Parser.tagOfToken\n               |> Parser.tokenTagToTokenId),\n              token\n            with\n        | EndOfStructuredConstructToken, _ -> os.Append(OBlockEndSentenceE().Format) |> ignore\n        | Parser.TOKEN_LEX_FAILURE, Parser.LEX_FAILURE str -> Printf.bprintf os $\"%s{str}\" (* Fix bug://2431 *)\n        | token, _ ->\n            os.Append(UnexpectedE().Format(token |> tokenIdToText))\n            |> ignore\n\n        (* Search for a state producing a single recognized non-terminal in the states on the stack *)\n        let foundInContext =\n\n            (* Merge a bunch of expression non terminals *)\n            let (|NONTERM_Category_Expr|_|) =\n                function\n                | Parser.NONTERM_argExpr\n                | Parser.NONTERM_minusExpr\n                | Parser.NONTERM_parenExpr\n                | Parser.NONTERM_atomicExpr\n                | Parser.NONTERM_appExpr\n                | Parser.NONTERM_tupleExpr\n                | Parser.NONTERM_declExpr\n                | Parser.NONTERM_braceExpr\n                | Parser.NONTERM_braceBarExpr\n                | Parser.NONTERM_typedSequentialExprBlock\n                | Parser.NONTERM_interactiveExpr -> Some()\n                | _ -> None\n\n            (* Merge a bunch of pattern non terminals *)\n            let (|NONTERM_Category_Pattern|_|) =\n                function\n                | Parser.NONTERM_constrPattern\n                | Parser.NONTERM_parenPattern\n                | Parser.NONTERM_atomicPattern -> Some()\n                | _ -> None\n\n            (* Merge a bunch of if/then/else non terminals *)\n            let (|NONTERM_Category_IfThenElse|_|) =\n                function\n                | Parser.NONTERM_ifExprThen\n                | Parser.NONTERM_ifExprElifs\n                | Parser.NONTERM_ifExprCases -> Some()\n                | _ -> None\n\n            (* Merge a bunch of non terminals *)\n            let (|NONTERM_Category_SignatureFile|_|) =\n                function\n                | Parser.NONTERM_signatureFile\n                | Parser.NONTERM_moduleSpfn\n                | Parser.NONTERM_moduleSpfns -> Some()\n                | _ -> None\n\n            let (|NONTERM_Category_ImplementationFile|_|) =\n                function\n                | Parser.NONTERM_implementationFile\n                | Parser.NONTERM_fileNamespaceImpl\n                | Parser.NONTERM_fileNamespaceImpls -> Some()\n                | _ -> None\n\n            let (|NONTERM_Category_Definition|_|) =\n                function\n                | Parser.NONTERM_fileModuleImpl\n                | Parser.NONTERM_moduleDefn\n                | Parser.NONTERM_interactiveDefns\n                | Parser.NONTERM_moduleDefns\n                | Parser.NONTERM_moduleDefnsOrExpr -> Some()\n                | _ -> None\n\n            let (|NONTERM_Category_Type|_|) =\n                function\n                | Parser.NONTERM_typ\n                | Parser.NONTERM_tupleType -> Some()\n                | _ -> None\n\n            let (|NONTERM_Category_Interaction|_|) =\n                function\n                | Parser.NONTERM_interactiveItemsTerminator\n                | Parser.NONTERM_interaction\n                | Parser.NONTERM__startinteraction -> Some()\n                | _ -> None\n\n            // Canonicalize the categories and check for a unique category\n            ctxt.ReducibleProductions\n            |> List.exists (fun prods ->\n                match prods\n                      |> List.map Parser.prodIdxToNonTerminal\n                      |> List.map (function\n                          | NONTERM_Category_Type -> Parser.NONTERM_typ\n                          | NONTERM_Category_Expr -> Parser.NONTERM_declExpr\n                          | NONTERM_Category_Pattern -> Parser.NONTERM_atomicPattern\n                          | NONTERM_Category_IfThenElse -> Parser.NONTERM_ifExprThen\n                          | NONTERM_Category_SignatureFile -> Parser.NONTERM_signatureFile\n                          | NONTERM_Category_ImplementationFile -> Parser.NONTERM_implementationFile\n                          | NONTERM_Category_Definition -> Parser.NONTERM_moduleDefn\n                          | NONTERM_Category_Interaction -> Parser.NONTERM_interaction\n                          | nt -> nt)\n                      |> Set.ofList\n                      |> Set.toList\n                    with\n                | [ Parser.NONTERM_interaction ] ->\n                    os.Append(NONTERM_interactionE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_hashDirective ] ->\n                    os.Append(NONTERM_hashDirectiveE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_fieldDecl ] ->\n                    os.Append(NONTERM_fieldDeclE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_unionCaseRepr ] ->\n                    os.Append(NONTERM_unionCaseReprE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_localBinding ] ->\n                    os.Append(NONTERM_localBindingE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_hardwhiteLetBindings ] ->\n                    os.Append(NONTERM_hardwhiteLetBindingsE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_classDefnMember ] ->\n                    os.Append(NONTERM_classDefnMemberE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_defnBindings ] ->\n                    os.Append(NONTERM_defnBindingsE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_classMemberSpfn ] ->\n                    os.Append(NONTERM_classMemberSpfnE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_valSpfn ] ->\n                    os.Append(NONTERM_valSpfnE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_tyconSpfn ] ->\n                    os.Append(NONTERM_tyconSpfnE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_anonLambdaExpr ] ->\n                    os.Append(NONTERM_anonLambdaExprE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_attrUnionCaseDecl ] ->\n                    os.Append(NONTERM_attrUnionCaseDeclE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_cPrototype ] ->\n                    os.Append(NONTERM_cPrototypeE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_objExpr | Parser.NONTERM_objectImplementationMembers ] ->\n                    os.Append(NONTERM_objectImplementationMembersE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_ifExprThen | Parser.NONTERM_ifExprElifs | Parser.NONTERM_ifExprCases ] ->\n                    os.Append(NONTERM_ifExprCasesE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_openDecl ] ->\n                    os.Append(NONTERM_openDeclE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_fileModuleSpec ] ->\n                    os.Append(NONTERM_fileModuleSpecE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_patternClauses ] ->\n                    os.Append(NONTERM_patternClausesE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_beginEndExpr ] ->\n                    os.Append(NONTERM_beginEndExprE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_recdExpr ] ->\n                    os.Append(NONTERM_recdExprE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_tyconDefn ] ->\n                    os.Append(NONTERM_tyconDefnE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_exconCore ] ->\n                    os.Append(NONTERM_exconCoreE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_typeNameInfo ] ->\n                    os.Append(NONTERM_typeNameInfoE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_attributeList ] ->\n                    os.Append(NONTERM_attributeListE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_quoteExpr ] ->\n                    os.Append(NONTERM_quoteExprE().Format) |> ignore\n                    true\n                | [ Parser.NONTERM_typeConstraint ] ->\n                    os.Append(NONTERM_typeConstraintE().Format)\n                    |> ignore\n\n                    true\n                | [ NONTERM_Category_ImplementationFile ] ->\n                    os.Append(NONTERM_Category_ImplementationFileE().Format)\n                    |> ignore\n\n                    true\n                | [ NONTERM_Category_Definition ] ->\n                    os.Append(NONTERM_Category_DefinitionE().Format)\n                    |> ignore\n\n                    true\n                | [ NONTERM_Category_SignatureFile ] ->\n                    os.Append(NONTERM_Category_SignatureFileE().Format)\n                    |> ignore\n\n                    true\n                | [ NONTERM_Category_Pattern ] ->\n                    os.Append(NONTERM_Category_PatternE().Format)\n                    |> ignore\n\n                    true\n                | [ NONTERM_Category_Expr ] ->\n                    os.Append(NONTERM_Category_ExprE().Format)\n                    |> ignore\n\n                    true\n                | [ NONTERM_Category_Type ] ->\n                    os.Append(NONTERM_Category_TypeE().Format)\n                    |> ignore\n\n                    true\n                | [ Parser.NONTERM_typeArgsActual ] ->\n                    os.Append(NONTERM_typeArgsActualE().Format)\n                    |> ignore\n\n                    true\n                | _ -> false)\n\n#if DEBUG\n        if not foundInContext then\n            Printf.bprintf\n                os\n                $\". (no 'in' context found: %+A{List.map (List.map Parser.prodIdxToNonTerminal) ctxt.ReducibleProductions})\"\n#else\n        foundInContext |> ignore // suppress unused variable warning in RELEASE\n#endif\n        let fix (s: string) =\n            s\n                .Replace(SR.GetString(\"FixKeyword\"), \"\")\n                .Replace(SR.GetString(\"FixSymbol\"), \"\")\n                .Replace(SR.GetString(\"FixReplace\"), \"\")\n\n        match (ctxt.ShiftTokens\n               |> List.map Parser.tokenTagToTokenId\n               |> List.filter (function\n                   | Parser.TOKEN_error\n                   | Parser.TOKEN_EOF -> false\n                   | _ -> true)\n               |> List.map tokenIdToText\n               |> Set.ofList\n               |> Set.toList)\n            with\n        | [ tokenName1 ] ->\n            os.Append(TokenName1E().Format(fix tokenName1))\n            |> ignore\n        | [ tokenName1; tokenName2 ] ->\n            os.Append(TokenName1TokenName2E().Format (fix tokenName1) (fix tokenName2))\n            |> ignore\n        | [ tokenName1; tokenName2; tokenName3 ] ->\n            os.Append(TokenName1TokenName2TokenName3E().Format (fix tokenName1) (fix tokenName2) (fix tokenName3))\n            |> ignore\n        | _ -> ()\n\n    os.ToString()\n\nlet parseFile\n    (isSignature: bool)\n    (sourceText: ISourceText)\n    (defines: string list)\n    : ParsedInput * FSharpParserDiagnostic list =\n    let errorLogger = CapturingDiagnosticsLogger(\"ErrorHandler\")\n\n    let parseResult =\n        let fileName =\n            if isSignature then\n                \"tmp.fsi\"\n            else\n                \"tmp.fsx\"\n\n        usingLexbufForParsing (createLexbuf \"preview\" sourceText, fileName) (fun lexbuf ->\n\n            let lexfun = createLexerFunction defines lexbuf errorLogger\n            // both don't matter for Fantomas\n            let isLastCompiland = false\n            let isExe = false\n\n            try\n                ParseInput(lexfun, errorLogger, lexbuf, None, fileName, (isLastCompiland, isExe))\n            with\n            | e ->\n                errorLogger.StopProcessingRecovery e range0 // don't re-raise any exceptions, we must return None.\n                EmptyParsedInput(fileName, (isLastCompiland, isExe)))\n\n    let diagnostics =\n        List.map\n            (fun (p, severity) ->\n                let range, message, errorNumber =\n                    match p.Exception with\n                    | :? IndentationProblem as ip -> Some ip.Data1, ip.Data0, Some 58\n                    | :? SyntaxError as se -> Some se.range, (getSyntaxErrorMessage se.Data0), Some 10\n                    | :? LibraryUseOnly as luo -> Some luo.range, LibraryUseOnlyE().Format, Some 42\n                    | _ -> None, p.Exception.Message, None\n\n                { Severity = severity\n                  SubCategory = \"parse\"\n                  Range = range\n                  ErrorNumber = errorNumber\n                  Message = message })\n            errorLogger.Diagnostics\n\n    parseResult, diagnostics\n",
  "options": {
    "ProjectFileName": "%CODE_ROOT%\\src\\Fantomas.FCS\\Fantomas.FCS.fsproj..NETStandard,Version=v2.0.fsproj",
    "ProjectId": null,
    "SourceFiles": [
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\FSComp.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\FSIstrings.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\UtilsStrings.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\.NETStandard,Version=v2.0.AssemblyAttributes.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\Fantomas.FCS.AssemblyInfo.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\AssemblyInfo.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\sformat.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\sformat.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\sr.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\sr.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\ResizeArray.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\ResizeArray.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\HashMultiMap.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\HashMultiMap.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\TaggedCollections.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\TaggedCollections.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\illib.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\illib.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\FileSystem.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\FileSystem.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\ildiag.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\ildiag.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\zmap.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\zmap.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\zset.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\zset.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\XmlAdapters.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\XmlAdapters.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\InternalCollections.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\InternalCollections.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\QueueList.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\QueueList.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\lib.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\lib.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\rational.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\rational.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\PathMap.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\PathMap.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\RidHelpers.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\range.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Utilities\\range.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\Logger.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\Logger.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\LanguageFeatures.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\LanguageFeatures.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\DiagnosticOptions.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\DiagnosticOptions.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\TextLayoutRender.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\TextLayoutRender.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\DiagnosticsLogger.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\DiagnosticsLogger.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\prim-lexing.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\prim-lexing.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\prim-parsing.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\Facilities\\prim-parsing.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\AbstractIL\\il.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\AbstractIL\\il.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\AbstractIL\\ilx.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\AbstractIL\\ilx.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\AbstractIL\\ilascii.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\AbstractIL\\ilascii.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\ilpars.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\illex.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\PrettyNaming.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\PrettyNaming.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\UnicodeLexing.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\UnicodeLexing.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\XmlDoc.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\XmlDoc.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\SyntaxTrivia.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\SyntaxTrivia.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\SyntaxTree.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\SyntaxTree.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\SyntaxTreeOps.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\SyntaxTreeOps.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\ParseHelpers.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\ParseHelpers.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\pppars.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\pars.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\LexHelpers.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\LexHelpers.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\pplex.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\generated\\netstandard2.0\\lex.fs",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\LexFilter.fsi",
      "%CODE_ROOT%\\paket-files\\dotnet\\fsharp\\src\\Compiler\\SyntaxTree\\LexFilter.fs",
      "%CODE_ROOT%\\src\\Fantomas.FCS\\Parse.fs"
    ],
    "OtherOptions": [
      "--out:%CODE_ROOT%\\src\\Fantomas.FCS\\bin\\Debug\\netstandard2.0\\Fantomas.FCS.dll",
      "--noframework",
      "--debug:full",
      "--debug+",
      "--optimize-",
      "--tailcalls-",
      "--fullpaths",
      "--flaterrors",
      "--highentropyva+",
      "--noconditionalerasure",
      "--warnon:1182",
      "--define:TRACE",
      "--define:COMPILER",
      "--define:DEBUG",
      "--define:NETSTANDARD",
      "--define:NETSTANDARD2_0",
      "--define:NETSTANDARD1_0_OR_GREATER",
      "--define:NETSTANDARD1_1_OR_GREATER",
      "--define:NETSTANDARD1_2_OR_GREATER",
      "--define:NETSTANDARD1_3_OR_GREATER",
      "--define:NETSTANDARD1_4_OR_GREATER",
      "--define:NETSTANDARD1_5_OR_GREATER",
      "--define:NETSTANDARD1_6_OR_GREATER",
      "--define:NETSTANDARD2_0_OR_GREATER",
      "--target:library",
      "--warn:3",
      "--doc:generated\\netstandard2.0\\Fantomas.FCS.xml",
      "--targetprofile:netstandard",
      "--nowarn:57,NU1603,NU1604,NU1605,NU1608",
      "--warnaserror:3239",
      "-r:%NUGET_PACKAGES%\\fsharp.core\\6.0.1\\lib\\netstandard2.0\\FSharp.Core.dll",
      "-r:%NUGET_PACKAGES%\\fslexyacc.runtime\\10.2.0\\lib\\netstandard2.0\\FsLexYacc.Runtime.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\Microsoft.Win32.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\mscorlib.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\netstandard.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.AppContext.dll",
      "-r:%NUGET_PACKAGES%\\system.buffers\\4.5.1\\ref\\netstandard2.0\\System.Buffers.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Collections.Concurrent.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Collections.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Collections.NonGeneric.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Collections.Specialized.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ComponentModel.Composition.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ComponentModel.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ComponentModel.EventBasedAsync.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ComponentModel.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ComponentModel.TypeConverter.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Console.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Core.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Data.Common.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Data.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.Contracts.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.Debug.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.FileVersionInfo.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.Process.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.StackTrace.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.TextWriterTraceListener.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.Tools.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.TraceSource.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Diagnostics.Tracing.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Drawing.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Drawing.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Dynamic.Runtime.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Globalization.Calendars.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Globalization.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Globalization.Extensions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.Compression.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.Compression.FileSystem.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.Compression.ZipFile.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.FileSystem.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.FileSystem.DriveInfo.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.FileSystem.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.FileSystem.Watcher.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.IsolatedStorage.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.MemoryMappedFiles.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.Pipes.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.IO.UnmanagedMemoryStream.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Linq.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Linq.Expressions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Linq.Parallel.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Linq.Queryable.dll",
      "-r:%NUGET_PACKAGES%\\system.memory\\4.5.4\\lib\\netstandard2.0\\System.Memory.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.Http.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.NameResolution.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.NetworkInformation.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.Ping.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.Requests.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.Security.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.Sockets.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.WebHeaderCollection.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.WebSockets.Client.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Net.WebSockets.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Numerics.dll",
      "-r:%NUGET_PACKAGES%\\system.numerics.vectors\\4.5.0\\ref\\netstandard2.0\\System.Numerics.Vectors.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ObjectModel.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Reflection.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Reflection.Extensions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Reflection.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Resources.Reader.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Resources.ResourceManager.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Resources.Writer.dll",
      "-r:%NUGET_PACKAGES%\\system.runtime.compilerservices.unsafe\\6.0.0\\lib\\netstandard2.0\\System.Runtime.CompilerServices.Unsafe.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.CompilerServices.VisualC.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Extensions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Handles.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.InteropServices.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.InteropServices.RuntimeInformation.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Numerics.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Serialization.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Serialization.Formatters.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Serialization.Json.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Serialization.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Runtime.Serialization.Xml.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Claims.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Cryptography.Algorithms.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Cryptography.Csp.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Cryptography.Encoding.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Cryptography.Primitives.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Cryptography.X509Certificates.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.Principal.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Security.SecureString.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ServiceModel.Web.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Text.Encoding.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Text.Encoding.Extensions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Text.RegularExpressions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.Overlapped.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.Tasks.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.Tasks.Parallel.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.Thread.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.ThreadPool.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Threading.Timer.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Transactions.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.ValueTuple.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Web.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Windows.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.Linq.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.ReaderWriter.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.Serialization.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.XDocument.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.XmlDocument.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.XmlSerializer.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.XPath.dll",
      "-r:%NUGET_PACKAGES%\\netstandard.library\\2.0.3\\build\\netstandard2.0\\ref\\System.Xml.XPath.XDocument.dll"
    ],
    "ReferencedProjects": [],
    "IsIncompleteTypeCheckEnvironment": false,
    "UseScriptResolutionRules": false,
    "LoadTime": "2022-06-04T00:42:05.5870681+01:00",
    "UnresolvedReferences": null,
    "OriginalLoadReferences": [],
    "Stamp": {
      "Case": "Some",
      "Fields": [
        0
      ]
    }
  }
}